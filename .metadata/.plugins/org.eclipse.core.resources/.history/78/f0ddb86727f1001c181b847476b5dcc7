--<북스-4장.다양한 함수>
/*****<문자함수>******************************************/
--1. 대소문자 변환함수
select 'Apple',
upper('Apple'),		--대문자로 변환
lower('Apple'),		--소문자로 변환
initcap('aPPLE')	--첫글자만 대문자, 나머지는 소문자로 변환
from dual;--가상테이블

--대소문자 변환함수 어떻게 활용되는지 살펴보기
--'scott' 사원의 사원번호, 이름, 부서번호 출력
select * from employee;

select ename, lower(ename), initcap(ename)
from employee;

select eno, ename, dno
from employee
where lower(ename) = 'scott';
--비교대상인 사원이름을 모두 소문자로 변환하여 비교

select eno, ename, dno
from employee
where ename = upper('scott');
--값을 대문자로 변환하여 비교

select eno, ename, dno
from employee
where initcap(ename) = 'Scott';


--2. 문자길이를 반환하는 함수
--영문, 수, 특수문자(1byte) 또는 한글의 길이 구하기
--length() : 문자 수
select length('Apple'), length('사과')
from dual;--5  2

--lengthB() : 한글2bytes-'인코딩 방식'에 따라 달라짐(UTF-8:한글 1글자가 '3바이트')
select lengthB('Apple'), lengthB('사과')
from dual;	--5바이트  6바이트

--3. 문자 조작 함수
--concat('문자열1', '문자열2') : '두 문자열'을 하나의 문자열로 연결(=결합)
--		★반드시 2 문자열만 연결 가능 = 매개변수 2개만
--매개변수=인수=인자=argument
select 'Apple', '사과',
concat('Apple', '사과') as "함수 사용",--자바에서는 "Apple".concat("사과")
'Apple' || '사과' || '맛있어' as "|| 사용"--자바에서는 "Apple" + "사과" + "맛있어"
from dual;

--substr(기존문자열, 시작index, 추출할 개수) : 문자열의 일부만 추출하여 부분문자열
--시작index : 음수이면 문자열의 마지막을 기준으로 거슬러 올라감
--인덱스(index) : 1 2 3...(※자바 index : 0 1 2...)
select substr('apple mania', 7, 5),--'mania'
substr('apple mania', -11, 5)--'apple'
from dual;

--[문제1] '이름이 N으로 끝나는' 사원 정보 표시
--방법-1:like연산자와 와일드카드(% _) 이용
select *
from employee
where ename LIKE '%N';

--방법-2:substr() 이용
select *
from employee
where substr(ename, -1, 1) = 'N';

select *
from employee
where lower(substr(ename, -1, 1)) = 'n';

select ename, substr(ename, -1, 1)
from employee
where substr(ename, -1, 1) = 'N';

select *
from employee
where substr(ename, length(ename), 1) = 'N';

--[문제2] 87년도에 입사한 사원 정보 탐색
--[방법-1]
select *
from employee
where substr(hiredate, 1, 2) = '87';	--오라클 : 날짜 기본 형식 'YY/MM/DD'
--where substr(hiredate, 1, 4) = '1987';	--결과 없음

--[방법-2]
--TO_CHAR(수나 날짜, '형식') : 수나 날짜를 원하는 형식의 문자로 형변환함
select *
from employee
--where substr(to_char(hiredate, 'yyyy'), 1 , 4) = '1987';--substr('1987', 1, 4)
where substr(to_char(hiredate, 'yyyy-mm-dd'), 1, 4) = '1987';--substr('1987-11-12', 1, 4)

--[문제3] '급여가 50으로 끝나는' 사원의 사원이름과 급여 출력
--[방법-1]
select ename, salary
from employee
where salary LIKE '%50';	--salary는 실수 number(7,2)타입이지만 '문자로 자동형변환'되어 비교

--[방법-2]
select ename, salary
from employee		--시작index : 끝에서 2번째부터 ㅣ작해서 2개 문자로 부분문자열 생성
--where substr(salary, -2, 2) = '50';	--salary는 실수 number(7,2)타입이지만 '문자로 자동형변환'
where substr(salary, -2, 2) = 50;	--'50'=50		50=50 (문자'50'이 수50으로 자동형변환되어 비교됨)

--[방법-3] : 자동 형변환되어 비교된다는 사실을 모르면?
--substr()는 문자함수
select ename, salary
from employee
where substr(to_char(salary), -2, 2) = '50';--TO_CHAR(수나 날짜)를 문자로 형변환해야 함

--substrB(기본문자열, 시작index, 추출할 바이트수)
select substr('사과매니아', 1, 2), -- '사과'
substrB('사과매니아', 1, 3),--'사' 1부터 시작해서 3바이트 추출해서 부분문자열을 생성
substrB('사과매니아', 4, 3),--'과'
substrB('사과매니아', 1, 6)--'사과'
from dual;

--instr(대상문자열, 찾을 문자열, 시작 index, 몇 번째 발견) : '대상문자열' 내에서 '시작index'부터 시작해서 '몇 번째 발견'하는 '해당 문자열'을 찾아 index번호 리턴
--즉, 찾을 문자열이 어느 '위치(=index번호)'에 있는지와 대상문자열에 존재하는지의 여부를 알 수 있다.
--'시작 index, 몇 번째 발견' 생략하면 모두 1로 간주
--(예)instr('대상문자열', '찾을문자') == instr('대상문자열', '찾을문자', 1, 1)
--찾는 문자가 없으면 0을 결과로 돌려줌(※자바에서는 -1을 돌려줌)
--자바에서는 "행복,사랑".indexOf("사랑") == 3(※자바의 index는 0부터 시작)
select instr('apple', 'p'), instr('apple', 'p', 1, 1),--2 2
	   instrB('apple', 'p'), instrB('apple', 'p', 1, 1),--2 2
	   instr('apple', 'p', 1, 2)	--3('apple'내에서 1부터 시작해서 두 번째 발견하는 'p'를 찾아 index 번호 리턴)
from dual;

select instr('apple', 'p', 2, 2)
from dual;	--3

select instr('apple', 'p', 3, 1)
from dual;	--3

select instr('apple', 'p', 3, 2)
from dual;	--0:찾는 문자가 없다.(※자바에서는 -1을 돌려줌)

select instr('apple', 'pl', 1, 1)
from dual;	--3

--영어는 무조건 1글자에 1byte, 그러나 한글은 인코딩방식에 따라 달라짐
--'바나나'에서 '나'문자가 1부터 시작해서 1번째 발견되는 '나'를 찾아 위치(index번호)=?
select instr('바나나', '나'), instr('바나나', '나', 1, 1),		--2		2
	   instrB('바나나', '나'), instrB('바나나', '나', 1, 1)		--4		4
from dual;

--'바나나'에서 '나'문자가 2부터 시작해서 2번째 발견되는 '나'를 찾아 위치(index번호)=?
select instr('바나나', '나', 2, 2),		--3
	   instrB('바나나', '나', 2, 2)		--7
from dual;

--이름의 세번째 글자가 'R'인 사원의 정보 검색
--[방법-1]
select *
from employee
where ename LIKE '__R%';

--[방법-2]
select *
from employee
where substr(ename, 3, 1) = 'R';
--where substr(ename, 3, 1) = upper('r');

--[방법-3]
select *
from employee
where instr(ename, 'R', 3, 1) = 3;
--where instr(ename, 'R') = 3;


--LPAD(Left Padding) : '컬럼'이나 대상문자열을 명시된 자릿수에서 오른쪽에 나타내고
--남은 왼쪽은 특정 기호로 채움

--10자리를 마련 후 salary는 오른쪽, 남은 왼쪽자리를 '*'로 채움
select salary, LPAD(salary, 10, '*')
from employee;

select salary, LPAD(salary, 10, ' ')		--' '로 채움
from employee;

--10자리를 마련 후 salary는 왼쪽, 남은 오른쪽자리를 '*'로 채움
select salary, RPAD(salary, 10, '*')
from employee;

--LTRIM('  문자열') : 문자열의 '왼쪽'공백 제거
--RTRIM('문자열  ') : 문자열의 '오른쪽'공백 제거
--TRIM('  문자열  ') : 문자열의 '양쪽'공백 제거
select '  사과매니아  ' || '입니다.',
LTRIM('  사과매니아  ') || '입니다.',
RTRIM('  사과매니아  ') || '입니다.',
 TRIM('  사과매니아  ') || '입니다.'
from dual;


--TRIM('특정문자1개만' from 컬럼이나 '대상문자열')
--컬럼이나 '대상문자열'에서 '특정문자'가 '첫 번째 글자'이거나 '마지막 글자'이면 잘라내고
--남은 문자열만 결과로 반환(=리턴=돌려줌)
select trim('사과' from '사과매니아')
from dual;	/*오류 메시지 : trim set should have only one character*/

select trim('사' from '사과매니아')
from dual;	--'과매니아'

select trim('아' from '사과매니아')
from dual;	--'사과매니'

select trim('과' from '사과매니아')
from dual;	--'사과매니아' : '과'가 처음이나 마지막 글자가 아니므로 잘라내지 못해 '사과매니아'그대로 결과 리턴

/********* <숫자함수>-북스 114p~ ********************************************/

--	-2(백) -1(십) 0(일) . 1  2  3

--1. round(대상, 화면에 표시되는 자릿수) : 반올림
--단, 자릿수 생략하면 0으로 간주
select 98.7654,
ROUND(98.7654),		--99
ROUND(98.7654, 0),	--99 		일의 자리까지 표시. 소수 1째자리에서 반올림하여
ROUND(98.7654, 2),	--98.77   소수 2째자리까지 표시. 소수 3째자리에서 반올림하여
ROUND(98.7654, -1)	--100	 	십의 자리까지 표시. 일의 자리에서 반올림하여
from dual;

--2. trunc(대상, 화면에 표시되는 자릿수) : '화면에 표시되는 자릿수'까지 남기고 나머지 버림
--단, 자릿수 생략하면 0으로 간주
select 98.7654,
TRUNC(98.7654),		--98
TRUNC(98.7654, 0),	--98 		일의 자리까지 표시.
TRUNC(98.7654, 2),	--98.76   소수 2째자리까지 표시.
TRUNC(98.7654, -1)	--90	 	십의 자리까지 표시.
from dual;

--3. mod(수1, 수2) : 수1을 수2로 나눈 나머지
select MOD(10, 3)
from dual;

--사원이름, 급여, 급여를 500으로 나눈 나머지 출력
select ename, salary, MOD(salary, 500)
from employee;

/********* <날짜함수>-북스 117p~ ********************************************/
--1. sysdate : 시스템으로부터 오늘의 날짜와 시간을 반환 (★주의 : 뒤에 ()없음)
-- (※MySQL에서는 now())
select sysdate from dual;

--date + 수 = 날짜에서 수만큼 '지난 날짜'
--date - 수 = 날짜에서 수만큼 '이전 날짜'
--date - date = 일수
--date + 수/24 = 날짜 + 시간

select sysdate-1 as 어제,
sysdate 오늘,
sysdate + 1 as "내 일"
from dual;

--[문제]사원들의 현재까지의 근무일수 구하기(단, 실수이면 반올림하여 일의 자리까지 표시)
--근무일수=현재날짜-입사일
select '2022/06/14' - '2022/06/13' as "근무일수"
from dual;	--오류 : '문자'로 인식되어 연산 불가
--그래서, '문자'를 to_date('문자')이용하여 날짜로 변경
select to_date('2022-06-14') - to_date('2022/06/13') as "근무일수"
from dual;	--1(정수)

--[순서-1]
select sysdate, hiredate, sysdate - hiredate as "근무일수"	--실수
from EMPLOYEE;

--[순서-2]
select sysdate, hiredate, sysdate-hiredate as "근무일수", --실수
ROUND(sysdate - hiredate, 0) as "근무일수(정수)",	--반올림
TRUNC(sysdate - hiredate, 0) as "근무일수(정수)"	--버림
from EMPLOYEE;

--입사일에서 '월을 기준'으로 잘라내려면('월까지 표시', 나머지 버림)
select hiredate,
trunc(hiredate, 'month')--일은 01로 초기화, 시간은 0으로 초기화
from employee;

select sysdate,
trunc(sysdate, 'year'),	--'년까지 표시'하고 나머지 잘림
trunc(sysdate, 'month'),	--'월까지 표시'하고 나머지 잘림
trunc(sysdate, 'day'),	--요일 초기화(해당날짜에서 그 주의 지나간 일요일로 초기화)

trunc(sysdate),			-- '일까지 표시'하고 시간 잘림
trunc(sysdate, 'dd'),	-- '일까지 표시'하고 시간 잘림(윗줄과 동일 결과)
trunc(sysdate, 'hh24'),	-- '시까지 표시'하고 분과 초 잘림
trunc(sysdate, 'mi')	-- '분까지 표시'하고 초 잘림
from dual;

SELECT
TO_CHAR(SYSDATE ,'yyyy/mm/dd'), --오늘 날짜  
TO_CHAR(SYSDATE + 1 ,'yyyy/mm/dd'), --내일 날짜  
TO_CHAR(SYSDATE -1 ,'yyyy/mm/dd'), --어제 날짜  
TO_CHAR(TRUNC(SYSDATE,'dd') ,'yyyy/mm/dd hh24:mi:ss'), -- 오늘 정각 날짜
TO_CHAR(TRUNC(SYSDATE,'dd') + 1,'yyyy/mm/dd hh24:mi:ss'), -- 내일 정각 날짜
TO_CHAR(SYSDATE + 1/24/60/60 ,'yyyy/mm/dd hh24:mi:ss'), -- 1초 뒤 시간
TO_CHAR(SYSDATE + 1/24/60 ,'yyyy/mm/dd hh24:mi:ss'), -- 1분 뒤 시간
TO_CHAR(SYSDATE + 1/24 ,'yyyy/mm/dd hh24:mi:ss'), -- 1시간 뒤 시간
TO_CHAR(TRUNC(SYSDATE,'mm') ,'yyyy/mm/dd'), --이번 달 시작날짜
TO_CHAR(LAST_DAY(SYSDATE) ,'yyyy/mm/dd'), --이번 달 마지막 날
TO_CHAR(trunc(ADD_MONTHS(SYSDATE, + 1),'mm') ,'yyyy/mm/dd'), --다음 달 시작날짜
TO_CHAR(ADD_MONTHS(SYSDATE, 1) ,'yyyy/mm/dd hh24:mi:ss'), -- 다음달 오늘 날짜
TO_CHAR(TRUNC(SYSDATE, 'yyyy') ,'yyyy/mm/dd'), --올해 시작 일
TO_CHAR(TRUNC(ADD_MONTHS(SYSDATE, -12), 'dd'),'yyyy/mm/dd'), --작년 현재 일
TO_DATE(TO_CHAR(SYSDATE, 'YYYYMMDD')) - TO_DATE('19930315'), -- 두 날짜 사이 일수 계산
MONTHS_BETWEEN(SYSDATE, '19930315'), -- 두 날짜 사이의 월수 계산
TRUNC(MONTHS_BETWEEN(SYSDATE, '19930315')/12,0) --두 날짜 사이의 년수 계산
FROM DUAL; 

--2. monthS_between(날짜1, 날짜2) : 날짜1과 날짜2 사이에 개월 수 구하기
--※ 날짜1-날짜2=일수
select ename, sysdate, hiredate,
sysdate-hiredate as "근무일수",	
--오늘날짜-입사일자=근무일수(결과가 실수? 시간이 포함)
--그래서, to_char(수나 날짜, '형식') 문자로 변형 => 다시 date로 변형(모든 시간이 0으로 초기화)
to_date(to_char(sysdate, 'yyyy-mm-dd')),
to_date(to_char(hiredate, 'yyyy-mm-dd')),
--[방법-1:권장]모든 시간이 0으로 초기화되어 => 결과가 정수
to_date(to_char(sysdate, 'yyyy-mm-dd')) - to_date(to_char(hiredate, 'yyyy-mm-dd')) as "days1",
--[방법-2]모든 시간이 0으로 초기화되어 => 결과가 정수
to_date(to_char(sysdate, 'yyyy-mm-dd'), 'yyyy/mm/dd') as 비교1,	--	2022-06-21 00:00:00.0 => 사용함
to_date(to_char(sysdate), 'yyyy-mm-dd') as 비교2, 	--	0022-06-21 00:00:00.0 => 따라서, 사용안함
to_date(to_char(sysdate), 'yyyy-mm-dd') - to_date(to_char(hiredate), 'yyyy-mm-dd') as "days2",

monthS_between(sysdate, hiredate) as "근무개월수",		--실수(양수)
TRUNC(monthS_between(sysdate, hiredate), 0) as "근무개월수",	--정수(소수점 뒤 버림) 48.78 => 48
ROUND(monthS_between(sysdate, hiredate), 0) as "근무개월수",	--정수(반올림) 48.78 => 49
--★주의 : 날짜의 위치
monthS_between(hiredate, sysdate) as "근무개월수",		--실수(음수)
TRUNC(monthS_between(hiredate, sysdate)) as "근무개월수",	--정수(소수점 뒤 버림)
ROUND(monthS_between(hiredate, sysdate)) as "근무개월수"	--정수(반올림)
from employee;

--TO_CHAR(날짜, '형식')에 맞게 원하는 부분만 출력할 수 있다.
--입사일자를
select ename, hiredate,
to_char(hiredate, 'yyyy') as "년도만",
to_char(hiredate, 'mm') as "달만",
to_char(hiredate, 'dd') as "일만",
--오늘날짜를
to_char(sysdate, 'd') as "요일만",--1:일, 2:월, 3:화,...7:토
to_char(sysdate, 'hh24') as "시간만-24시간 기준",
to_char(sysdate, 'hh') as "시간만-12시간 기준",
to_char(sysdate, 'mi') as "분만",
to_char(sysdate, 'ss') as "초만"
from employee;

select to_char(sysdate, 'd') as "요일만(정수)",
DECODE(to_char(sysdate, 'd'),1,'일요일',2,'월요일',3,'화요일',4,'수요일',5,'목요일',6,'금요일',7,'토요일') as "요일만"--1:일, 2:월, 3:화,...7:토
from dual;

select sysdate,
to_char(sysdate, 'yyyy-mm-dd'),--날짜 - /
to_char(sysdate, 'yyyy/mm/dd'),
TO_DATE(to_char(sysdate, 'yyyy-mm-dd')),
TO_DATE(to_char(sysdate, 'yyyy/mm/dd'))
from dual;


--3. add_monthS(날짜, 더할 개월수) : 특정 개월수를 더한 날짜
select ename, hiredate,
add_monthS(hiredate, 3),
add_monthS(hiredate, -3)
from employee;

--4. next_day(날짜, '수요일') : 해당날짜를 기준으로 최초로 도래하는 요일에 해당하는 날짜 반환
select sysdate,
next_day('2022-05-14', '수요일'),
next_day(sysdate, '토요일'),
next_day(sysdate, 7) --일요일(1), 월요일(2), 화요일(3)...토요일(7)
from dual;

--5. last_day(날짜) : 해당 날짜가 속한 달의 마지막 날짜를 반환
--대부분 달의 경우, 마지막 날이 정해져 있지만
--2월달은 마지막 날이 25 또는 29가 될 수 있으므로 '2월에 사용하면 효과적임'
select sysdate, last_day(sysdate)
from dual;

select ename, hiredate, last_day(hiredate)
from employee;

--6. 날짜 또는 시간 차이 계산 방법
--날짜 차이 : 종료일자(yyyy-mm-dd) - 시간일자(yyyy-mm-dd)


--<4장 다양한 함수-혼자해보기>---------------------------------
/*
 * 1. SUBSTR 함수를 사용하여 사원들의 입사한 년도와 입사한 달만 출력하시오.
 */
--[방법-1]
select hiredate,
substr(hiredate, 1, 2) as "입사년도",
substr(hiredate, 4, 2) as "입사한 달"
from employee;	--저장된 날짜 기본 형식(YY/MM/DD)

--[방법-2]
select hiredate,
substr(to_char(hiredate, 'yyyy-mm-dd'), 1, 4) 년도,
substr(hiredate, 4, 2) 달
from employee;

/*
 * 2. SUBSTR 함수를 사용하여 4월에 입사한 사원을 출력하시오.
 */
--[방법-1]
select *
from employee
where substr(hiredate, 4, 2) = '04';--저장된 날짜 기본 형식(YY/MM/DD)

--[방법-2]
select *
from employee
where substr(to_char(hiredate, 'mm'), 1, 2) = '04';--저장된 날짜 형식을 변경 '월'만

--[방법-3]
select *
from employee
where substr(to_char(hiredate, 'yyyy/mm/dd'), 6, 2) = '04';

--[방법-4]
select *
from employee
where substr(hiredate, instr(hiredate, '04', 4, 1), 2) = '04';







