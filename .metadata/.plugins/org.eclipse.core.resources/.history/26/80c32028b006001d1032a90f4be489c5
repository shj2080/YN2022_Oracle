--<북스-7장. 서브쿼리>
--[문제] 'SCOTT'보다 급여를 많이 받는 사원의 사원명과 급여 조회
--[1]. 우선 'SCOTT'의 급여를 알아야 함
select salary
from employee
where ename='SCOTT';--3000

--[2]. 해당급여 3000보다 급여가 많은 사원의 사원명과 급여 검색
select ename, salary
from employee
where salary > 3000;

--[3]. [2]메인쿼리 - [1]서브쿼리
select ename, salary
from employee
where salary > (select salary
				from employee
				where ename='SCOTT');
				--서브쿼리에서 실행한 결과(3000)가 메인쿼리에 전달되어 최종 결과를 출력
				
--단일 행 서브쿼리 : 내부서브쿼리문의 결과가 행 '1개'
--               단일행 비교연산자(>,<,=,>=,<=), IN연산자
--               (예) salary > 3000
--                   salary = 3000와 salary IN(3000)는 같은 표현

--다중 행 서브쿼리 : 내부서브쿼리문의 결과가 행 '1개 이상'
--               다중행 비교연산자(IN, any, some, all, exists)
--               (예) salary IN(1000, 2000, 3000)

--1. 단일 행 서브쿼리
--[문제] 'SCOTT'과 동일한 부서에서 근무하는 사원이름, 부서번호 조회
--[1]. 우선 'SCOTT'의 부서번호 알기
select dno
from EMPLOYEE
where ename='SCOTT';--20		
				
--[2]. 해당부서번호(=20)와 같은 사원이름, 부서번호 검색
select ename, dno
from employee
where dno = (select dno
			from EMPLOYEE
			where ename='SCOTT');--서브쿼리 결과 : 1개	
			
select ename, dno
from employee
where dno IN (select dno
			from EMPLOYEE
			where ename='SCOTT');--서브쿼리 결과 : 1개 이상=여러개라도 가능
			
--위 결과에는 'SCOTT'도 함께 조회됨. 'SCOTT'은 제외하고 조회하려면			
select ename, dno
from employee
where dno = (select dno
			from EMPLOYEE
			where ename='SCOTT')
AND ename != 'SCOTT';--조건 추가
				
select ename, dno
from employee
where dno = 20 AND ename != 'SCOTT';	

--[문제] 회사 전체에서 '최소 급여'를 받는 사원의 이름, 담당업무(job), 급여 조회
--[1]. 최소 급여 구하기
select MIN(salary)
from employee;--800

--[2]. 구한 최소급여(800)를 받는 사원의 이름, 담당업무(job), 급여 조회
select ename, job, salary
from employee
where salary = (select MIN(salary)--서브쿼리 결과 : 1개
				from employee);
--where salary = 800;
				
select ename, job, salary
from employee
where salary IN (select MIN(salary)
				 from employee);						
--where salary IN(800);	

--2. 다중 행 서브쿼리
--1) IN 연산자 : 메인쿼리의 비교조건에서 서브쿼리의 출력결과롸 '하나라도 일치하면'
--             메인쿼리의 where절이 true
--★ 단일 또는 다중 행 서브쿼리 둘다 사용가능함

--[문제]★★★ "부서별 최소 급여"를 받는 사원의 부서번호, 사원번호, 이름, 최소급여를 조회	
--[방법-1]		
--[1]."부서별 최소 급여"를 구하기
select min(salary)
from EMPLOYEE
group by dno;--최종결과라면 이 결과가 무의미하다.

--[2]."부서별 최소 급여"를 받는 사원의 부서번호, 사원번호, 이름, 최소급여를 조회
select dno, eno, ename, salary
from EMPLOYEE
WHERE salary IN (select min(salary)--dno 제외함
				 from EMPLOYEE
				 group by dno)--IN( 1300,800,950 )
order by 1;

select dno, eno, ename, salary
from EMPLOYEE
WHERE salary IN (950, 800, 1300)
order by 1;

--[방법-2]
--[1]."부서별 최소 급여"를 구하기(dno까지 표시)
select dno, min(salary)--3:3
from EMPLOYEE
group by dno;--결과 : (10,1300),(20,800),(30,950)

--[2-1]서브쿼리  이용: ★★★ "부서별 최소 급여"를 받는 사원의 부서번호, 사원번호, 이름, 최소급여를 조회
select dno, eno, ename, salary
from EMPLOYEE
WHERE (dno ,salary) IN (select dno, min(salary)--IN( (10,1300),(20,800),(30,950) )
				        from EMPLOYEE
				        group by dno)
order by 1;

select dno, eno, ename, salary
from EMPLOYEE
WHERE (dno, salary) IN ((10,1300),(20,800),(30,950))
order by 1;

--[2-2] join 방법-1 이용
--[1]
select dno, min(salary)
from employee
group by dno;

--[2]
select *
from employee e1, (select dno, min(salary)
					from employee
					group by dno) e2
where e1.dno = e2.dno --조인조건
order by e1.dno;

--[3]
select e1.dno, eno, ename, salary
from employee e1, (select dno, min(salary) as "minSalary"
					from employee
					group by dno) e2
where e1.dno = e2.dno --조인조건
--AND salary = min(salary)  --검색조건=>오류?(where절에서 min()함수 사용하여)
--[오류해결]별칭 사용
AND salary = "minSalary"
order by e1.dno;

--[2-3] join 방법-2 이용----
select e1.dno, eno, ename, salary
from employee e1 JOIN (select dno, min(salary) as "minSalary"
					from employee
					group by dno) e2
ON e1.dno = e2.dno --조인조건
WHERE salary = "minSalary"	--검색조건
order by e1.dno;

--[2-4] join 방법-3 이용 : dno로 자연조인 -> 조인조건X, 중복제거->별칭X
select dno, eno, ename, salary
from employee natural JOIN (select dno, min(salary) as "minSalary"
					from employee
					group by dno)
WHERE salary = "minSalary"	--검색조건
order by dno;

--[2-5] join 방법-4 이용 : 중복제거->별칭X
select dno, eno, ename, salary
from employee JOIN (select dno, min(salary) as "minSalary"
					from employee
					group by dno)
USING(dno)--조인조건
WHERE salary = "minSalary"	--검색조건
order by dno;
----------------------------------------------------------------------------------------

--[위 문제의 '방법-1'의 쿼리에서 'min(salary)도 출력'하려면]
select min(salary)
from employee; --전체 사원 테이블이 대상이므로 1그룹

select dno, min(salary) -- 14:1 매칭불가=>오류
from employee;

select dno, min(salary) --dno 3그룹 : 3
from employee
GROUP BY dno
order by 1;

select dno, eno, ename, salary, min(salary) --"그룹함수 출력"하려면
from employee
GROUP BY dno, eno, ename, salary--GROUP BY절 뒤에 반드시 출력할 컬럼들 나열(그룹함수 제외)
order by 1;

select dno, eno, ename, salary, min(salary)
from employee
WHERE salary IN (950, 800, 1300) --검색조건
GROUP BY dno, eno, ename, salary
order by 1;
--[최종]
select dno, eno, ename, salary, min(salary)
from employee
WHERE salary IN (select min(salary)
				from employee
				group by dno)
GROUP BY dno, eno, ename, salary
order by 1;
----------------------------------------------------------------------------

--2) ANY 연산자 : 서브 쿼리가 반환하는 각각의 값과 비교
--WHERE 컬럼명 = any(서브쿼리의 결과1, 결과2) => 결과들 중 '아무거나와 같다'면 TRUE.
--WHERE 컬럼명 IN(서브쿼리의 결과1, 결과2) => 결과들 중 '아무거나와 같다'면 TRUE.

--정리 : A조건 OR B조건
--합집합 : 각각 만족하는 조건의 결과를 다 합침

--WHERE 컬럼명 < any(서브쿼리의 결과1, 결과2) => 결과들 중 "최대값"보다 작으면 TRUE.
--WHERE 컬럼명 > any(서브쿼리의 결과1, 결과2) => 결과들 중 "최소값"보다 크면 TRUE.

--[문제]★★★ "부서별 최소 급여"를 받는 사원의 부서번호, 사원번호, 이름, 최소급여를 조회
--[2-6] =ANY 이용
--[1]."부서별 최소 급여"를 구하기(dno까지 표시)
select dno, min(salary)--3:3
from EMPLOYEE
group by dno;--결과 : (10,1300),(20,800),(30,950)

--[2-1]서브쿼리  이용: ★★★ "부서별 최소 급여"를 받는 사원의 부서번호, 사원번호, 이름, 최소급여를 조회
select dno, eno, ename, salary
from EMPLOYEE
WHERE (dno ,salary) = any(select dno, min(salary)-- =ANY( (10,1300),(20,800),(30,950) )
				        from EMPLOYEE
				        group by dno)
order by 1;

--정리 : WHERE (dno, salary) = ANY( (10,1300),(20,800),(30,950) )
--		WHERE (dno, salary)   IN ( (10,1300),(20,800),(30,950) )
--		서브쿼리의 결과 중 '아무거나와 같다'면 TRUE

--정리 : WHERE salary != ANY(1300, 800, 950)
--		WHERE salary <> ANY(1300, 800, 950)
--		WHERE salary ^= ANY(1300, 800, 950)

--		WHERE salary NOT IN(1300, 800, 950)
--		서브쿼리의 결과 중 '어느 것도 아니면' TRUE

--정리 : WHERE salary < ANY(1300, 800, 950) 서브쿼리 결과들 중 "최대값(1300)"보다 작으면 TRUE.
--		WHERE salary > ANY(1300, 800, 950) 서브쿼리 결과들 중 "최소값(800)"보다 크면 TRUE.
--(예1)
select eno, ename, salary
from employee
where salary < ANY(1300, 800, 950)
order by 1;
--		salary < ANY(1300, 800, 950)
--		salary < 1300
--		salary < 800
--		salary < 950
--결국	salary < 1300(최대값)의 범위가 나머지 범위들 다 포함함

--(예2)
select eno, ename, salary
from employee
where salary < ANY(1300, 800, 950)
order by 1;
--		salary > ANY(1300, 800, 950)
--		salary > 1300
--		salary > 800
--		salary > 950
--결국	salary > 800(최소값)의 범위가 나머지 범위들 다 포함함


--[문제] 직급이 SALESMAN이 아니면서
--급여가 임의의 SALESMAN보다 낮은 사원의 정보(사원이름, 직급, 급여) 출력
--(※임의의 = '각각'으로 해석)
--[1]. 직급이 SALESMAN의 급여 구하기
select DISTINCT salary	--결과 :  1600 1250 1250 1500중복제거
from employee
where job = 'SALESMAN'; --->결과 : 1250 1600 1500

--[2]
select ename, job, salary
from employee
where job != 'SALESMAN'
AND salary < any(select distinct salary
				 from employee
				 where job = 'SALESMAN');
-- salary < ANY(1250 1600 1500)의 서브쿼리 결과 중 '최대값'보다 작으면 참

--위 결과를 검증
--[1]. 직급이 SALESMAN의 급여 구하기=>'직급이 SALESMAN의 최대급여 구하기'
select MAX(salary)
from employee
where job = 'SALESMAN';--1600

--[2]
select ename, job, salary
from employee
where job != 'SALESMAN'
AND salary < (select MAX(salary)
				from employee
				where job = 'SALESMAN');
----------------------------------------------------------------------------

--3) ALL 연산자 : 서브 쿼리에서 반환되는 모든 값과 비교
--정리 : A조건 and B조건
--교집합 : 모든 조건을 동시에 만족하는 것
				
--정리 : WHERE 컬럼명 < any(1300, 800, 950) => 서브결과들 중 "최대값(1300)"보다 작으면 TRUE.
--		WHERE 컬럼명 > any(1300, 800, 950) => 서브결과들 중 "최소값(800)"보다 크면 TRUE.
		
--정리 : WHERE 컬럼명 < ALL(1300, 800, 950) => 서브결과들 중 "최소값(800)"보다 작으면 TRUE.
--		WHERE 컬럼명 > ALL(1300, 800, 950) => 서브결과들 중 "최대값(1300)"보다 크면 TRUE.		
				

--[문제] 직급이 SALESMAN이 아니면서
--급여가 모든 SALESMAN보다 낮은 사원의 정보(사원이름, 직급, 급여) 출력
--[1]. 직급이 SALESMAN의 급여 구하기
select DISTINCT salary	--결과 :  1600 1250 1250 1500중복제거
from employee
where job = 'SALESMAN'; --->결과 : 1250 1600 1500

--[2]
select ename, job, salary
from employee
where job != 'SALESMAN'
AND salary < ALL(select distinct salary
				 from employee
				 where job = 'SALESMAN');
-- salary < ALL(1250 1600 1500)의 서브쿼리 결과 중 '최소값(1250)'보다 작으면 참

--위 결과를 검증
select min(salary)
from employee
where job = 'SALESMAN';

select ename, job, salary
from employee
where job != 'SALESMAN' AND salary < (select min(salary)
									from employee
									where job = 'SALESMAN');

---------------------------------------------------------------------------
--4) EXISTS 연산자 : EXISTS=존재하다.
select
from
where EXISTS (서브쿼리);
--서브쿼리에서 구해진 데이터가 1개라도 존재하면 true -> 메인쿼리 실행
--					  1개라도 존재하지 않으면 false -> 메인쿼리 실행X			

select
from
where NOT EXISTS (서브쿼리);
--서브쿼리에서 구해진 데이터가 1개라도 존재하지 않으면 true -> 메인쿼리 실행
--					  1개라도 존재하면 false -> 메인쿼리 실행X			

--[문제-1] 사원테이블에서 직업이 'PRESIDENT'가 있으면 모든 사원이름을 출력, 없으면 출력안함
--★ 문제의 뜻 : 조건을 만족하는 사원이 있으면 메인쿼리를 실행하여 결과를 출력

--[1] 사원테이블에서 직업이 'PRESIDENT'인 사원의 사원번호 조회
select eno
from employee
where job = 'PRESIDENT';

--[2]
select ename
from employee
where EXISTS (select eno --7839
			from employee
			where job = 'PRESIDENT');

--위 문제를 테스트하기 위해 직업이 'PRESIDENT'인 사원 삭제 후 다시 [2]실행 => 결과 없음(오류아님)
delete
from employee
where job = 'PRESIDENT';

--다시 되돌리기 위해 직업이 'PRESIDENT'인 사원 추가하기
INSERT INTO EMPLOYEE
VALUES(7839,'KING','PRESIDENT', NULL,to_date('17-11-1981','dd-mm-yyyy'),5000,NULL,10);

--[위 문제에 "job이 'SALESMAN'이면서" 라는 검색조건을 추가]
--조건을 AND 연결 : 두 조건이 모두 참이면 참
SELECT ENAME
from employee
where job='SALESMAN' AND EXISTS (select eno --7839
								from employee
								where job = 'PRESIDENT');
--결과 : 4명 AND 14명 => 동시에 만족 4명 

--[위 문제에 "job이 'SALESMAN'이거나" 라는 검색조건을 추가]
--조건을 OR 연결 : 두 조건 중 하나만 참이면 참
SELECT ENAME
from employee
where job='SALESMAN' OR EXISTS (select eno --7839
								from employee
								where job = 'PRESIDENT');
--결과 : 4명 OR 14명 => 14명

--[NOT EXISTS] 
--조건을 AND 연결 : 두 조건이 모두 참이면 참
SELECT ENAME
from employee
where job='SALESMAN' AND NOT EXISTS (select eno --7839
								from employee
								where job = 'PRESIDENT');
--결과 : 4명 AND 0명 => 동시에 만족 0명 
								
--조건을 OR 연결 : 두 조건 중 하나만 참이면 참
SELECT ENAME
from employee
where job='SALESMAN' OR NOT EXISTS (select eno --7839
								from employee
								where job = 'PRESIDENT');
--결과 : 4명 OR 0명 => 4명								

--[과제-1] : 사원테이블과 부서테이블에서 동시에 없는(참조되지 않은) 부서번호, 부서이름 조회
--(employee의 dno가 department의 dno를 references를 아는 전제 하에서
--즉, 'employee의 dno가 참조하는 dno는 반드시 department의 dno로 존재한다'는
--사실을 아는 전제 하에서 문제 해결함)
select dno, dname
from department
where dno NOT IN(select distinct dno
				from employee);
								
select d.dno, dname
from employee e, department d
where e.dno(+) = d.dno
AND e.dno IS NULL;

select e.ename, e.dno, d.dno, dname
from employee e, department d
where e.dno(+) = d.dno;

select d.dno, dname
from employee e RIGHT OUTER JOIN department d
ON e.dno = d.dno
where e.dno IS NULL;

--<7장.서브쿼리-혼자해보기>----------------------------------
--1.사원번호가 7788인 사원과 '담당업무가 같은' 사원을 표시(사원이름과 담당업무)
select ename, job
from employee
where job = (select job
			from employee
			where eno = 7788);

--2.사원번호가 7499인 사원보다 급여가 많은 사원을 표시(사원이름과 담당업무)
select ename, job
from employee
where salary > (select salary
				from employee
				where eno = 7499);

--3.최소급여를 받는 사원의 이름, 담당 업무 및 급여 표시(그룹함수 사용)
select ename, job, salary
from employee
where salary = (select min(salary)
				from employee);

--4.'직급별' 평균 급여가 가장 적은 담당 업무를 찾아 '직급(job)'과 '평균 급여' 표시
--단, 평균의 최소급여는 반올림하여 소수1째자리까지 표시
select round(min(avg(salary)), 1) as "avgSalary"
from employee
group by job;
				
				
select job as "직급", salary as "평균 급여"
from employee, (select round(min(avg(salary)), 1) as "avgSalary"
from employee
group by job)
where 
				
select * from employee;			
--5.각 부서의 최소 급여를 받는 사원의 이름, 급여, 부서 번호 표시
select dno, min(salary)
from employee
group by dno;

select ename, salary, dno
from employee, (select 1)

--6.'담당 업무가 분석가(ANALYST)인 사원보다 급여가 적으면서 업무가 분석가가 아닌' 
--사원들을 표시(사원번호, 이름, 담당 업구, 급여)

--★★7.부하직원이 없는 사원이름 표시(먼저 '문제 8. 부하직원이 있는 사원이름 표시'부터 풀기)

--★★8.부하직원이 있는 사원이름 표시

--9.BLAKE와 동일한 부서에 속한 사원이름과 입사일을 표시(단,BLAKE는 제외)

--10.급여가 평균 급여보다 많은 사원들의 사원번호와 이름 표시(결과는 급여에 대해 오름차순 정렬)

--11.이름에 K가 포함된 사원과 같은 부서에서 일하는 사원의 사원번호와 이름 표시

--12.부서위치가 DALLAS인 사원이름과 부서번호 및 담당 업무 표시

--[과제-1]
--[12번 변경문제]. 부서위치가 DALLAS인 사원이름, 부서번호, 담당 업무, + '부서위치' 표시 

--13.KING에게 보고하는 사원이름과 급여 표시

--14.RESEARCH 부서의 사원에 대한 부서번호, 사원이름, 담당 업무 표시

--15.평균 급여보다 많은 급여를 받고 이름에 M이 포함된 사원과 같은 부서에서 근무하는 
--사원번호,이름,급여 표시

--16.평균 급여가 가장 적은 업무와 그 평균급여 표시

--17.담당 업무가 MANAGER인 사원이 소속된 부서와 동일한 부서의 사원이름 표시