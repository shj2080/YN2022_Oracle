--<북스-6장.테이블 조인하기>
--1. 조인
--1.1 카디시안 곱(=곱집합) : (구방식 ,) (현방식 cross join) - 조인조건이 없다.
select * from EMPLOYEE; 	--컬럼(속성)수 : 8, 행수:14
select * from department;   --컬럼수:3, 행수:4

select *	--컬럼수:11, 행수:56
from employee, department;
--조인결과 : 컬럼수(11) = 사원테이블의 컬럼수(8) + 부서테이블의 컬럼수(3)
--		   행수(56) = 사원테이블의 컬럼수(14) * 부서테이블의 컬럼수(4)
--		   	       = 사원테이블의 사원 1명 당 * 부서테이블의 행수(4)

select eno	-- eno 컬럼만, 56개 전체 행수
from employee, department;

select eno	-- eno 컬럼만, 56개 전체 행수
from employee CROSS JOIN department;

select *	--컬럼수:11, eno가 7369인 것만
from employee, department
where eno = 7369;--(조인조건아님)검색조건

--1.2 조인의 유형
--오라클 8i이전 조인 : EQUI 조인(=등가 조인), non-EQUI 조인(=비등가 조인), outer 조인(왼쪽, 오른쪽), self 조인
--오라클 9i이후 조인 : cross 조인, natural 조인(=자연 조인), join~using, outer 조인(왼쪽, 오른쪽, full까지)
--(※오라클 9i부터 ANSI 표준 SQL 조인 : 현재 대부분의 상용 데이터베이스 시스템에서 사용.
--								다른 DBMS와 호환이 가능하기 때문에 ANSI 표준 조인에 대해서 확실히 학습하자.)

--------<아래 4가지 비교 : 내부조인(=inner join)>------------------------------------------------------------------
--[해결할 문제] '사원번호가 7788'인 사원이 소속된 '사원번호, 사원이름, 소속부서번호, 소속부서이름' 얻기
-- 먼저, '사원번호, 사원이름, 소속부서번호, 소속부서이름'의 컬럼들이 어느 테이블에 있는지 부터 파악하기
-- '사원번호, 사원이름, 소속부서번호(dno)' => 사원테이블에 있음
-- '소속부서번호(dno), 소속부서이름' => 부서테이블에 있음

-- '소속부서번호'가 양 테이블에 존재하므로 등가 조인이 가능함
--2. equi 조인(=등가 조인=동일조인) : 동일한 이름과 유형(=데이터 타입)을 가진 컬럼으로 조인
--  단, [방법-1] , ~ where 과 [방법-2] JOIN ~ ON은 '데이터 타입만 같아도 조인'이 됨

--[방법-1] , ~ where ------------------------------------------------------------------------------------------------------------------------------------
--동일한 이름과 데이터 유형을 가진 컬럼으로 조인 + "임의의 조건을 지정"하거나 "조인한 컬럼을 지정"할 때 where절을 사용
--조인결과는 중복된 컬럼 제거X -> 따라서, 테이블에 '별칭 사용'해서 어느 테이블의 컬럼인지 구분해야 함
select 컬럼명1, 컬럼명2...--중복되는 컬럼은 반드시 '별칭.컬럼명'(예)e.dno	d.dno
from 테이블1 별칭1, 테이블2 별칭2, ... --별칭사용(별칭 : 해당 SQL명령문내에서만 유효)
where ★조인조건	(※주의 : 테이블의 별칭 사용);
AND	  ★(검색조건)	(※주의 : 습관적으로 () 사용하기)
--★문제점 : 원하지 않는 결과가 나올 수 있다.(이유? AND -> OR의 우선순위 때문에)
--★문제점 해결법 : AND	  ★검색조건에서 '괄호()를 이용하여 우선순위 변경'
--예)부서번호로 조인한 후 부서번호가 10이거나 30인 정보 조회
--where e.dno = d.dno AND d.dno = 10 OR d.dno = 30; --문제 발생(원하지 않는 결과 나옴)
--where e.dno = d.dno AND (d.dno = 10 OR d.dno = 30);--★해결법 : '괄호()를 이용하여 우선순위 변경'

--★★★ [장점] 이 방법은 outer join(=외부조인) 하기가 편리하다.
--(단, 한 쪽에만 (+)사용가능  -> 즉, 왼쪽과 오른쪽 외부조인만 가능.
--		양쪽에 (+)사용불가  -> 즉, full 외부조인은 불가 )
--[1]
select *
from employee, department
order by eno;
--[2]별칭 사용 안한 경우
select *
from employee, department
where employee.dno = department.dno;
--[2]별칭 사용한 경우
select *
from employee e, department d
where e.dno = d.dno;
--두 테이블에서 같은 dno끼리 조인(그 결과 부서테이블의 40은 표시안됨.)

-- 40부서의 정보를 함께 표시하기 위해서는 (+)붙여서 outer join(=외부조인)함.
--[3]
select *
from employee e, department d
where e.dno(+) = d.dno;
--외부조인하기 편리하나 full outer join 안됨
--full outer join은 join~on으로 해결가능함

--[3] 아래 결과는 같다. 그 이유? DEPARTMENT 테이블에만 표시될 내용이 더 있으므로...
select *
from employee e RIGHT OUTER JOIN department d
ON e.dno = d.dno;

select *
from employee e FULL OUTER JOIN department d
ON e.dno = d.dno;

--[해결할 문제] '사원번호가 7788'인 사원이 소속된 '사원번호, 사원이름, 소속부서번호, 소속부서이름' 얻기
--[방법-1문제해결법]
select eno, ename, e.dno, dname	--별칭사용 : 두 테입믈에 모두 존재하므로 구분하기 위해
from employee e, department d
where e.dno = d.dno
AND eno = 7788;

--[방법-2] (INNER)JOIN ~ ON ------------------------------------------------------------------------------------------------------------------------------------
--동일한 이름과 데이터 유형을 가진 컬럼으로 조인 + "임의의 조건을 지정"하거나 "조인한 컬럼을 지정"할 때 ON절을 사용
--조인결과는 중복된 컬럼 제거X -> 따라서, 테이블에 '별칭 사용'해서 어느 테이블의 컬럼인지 구분해야 함
select 컬럼명1, 컬럼명2...--중복되는 컬럼은 반드시 '별칭.컬럼명'(예)e.dno	d.dno
from 테이블1 별칭1 (INNER)JOIN 테이블2 별칭2, ... --별칭사용(별칭 : 해당 SQL명령문내에서만 유효)
ON 		  ★조인조건	(※주의 : 테이블의 별칭 사용);
where	  ★(검색조건)

--[해결할 문제] '사원번호가 7788'인 사원이 소속된 '사원번호, 사원이름, 소속부서번호, 소속부서이름' 얻기
--[방법-2문제해결법]
select eno, ename, d.dno, dname	--별칭사용 : 두 테입믈에 모두 존재하므로 구분하기 위해
from employee e JOIN department d
ON e.dno = d.dno
where eno = 7788;

-------------------------------------[방법-1]과 [방법-2]는 문법적 특징이 동일하다.
-------------------------------------				의 조인 결과 : 중복된 컬럼 제거X -> 테이블의 별칭 필요
-------------------------------------			  ★ 컬럼명이 다르고 데이터 타입만 같아도 JOIN 가능 (예)a.id = b.id2

-------------------------------------[방법-3] : 컬럼명이 다르면 cross join 결과가 나옴
-------------------------------------[방법-4] : 컬럼명이 다르면 join 안됨 (=>오류 발생)


--[방법-3] NATURAL JOIN (=자연조인) ------------------------------------------------------------------------------------------------------------------------------------
--※ Oracle SQL에서만 지원
--조인결과, 중복된 컬럼 제거함

--'자연스럽게' 동일한 이름과 데이터 유형을 가진 컬럼으로 조인(★단, 1개만 있을 때 사용하는 것을 권장)
--동일한 이름과 데이터 유형을 가진 컬럼이 없으면 cross join 이 됨
--★★ 동일한 이름과 데이터 유형을 가진 컬럼으로 자연스럽게 조인되나 문제가 발생할 수 있다.
-----> 문제 발생하는 이유? (예)


--[방법-4] JOIN ~ USING(★반드시 '동일한 컬럼명'만 가능) ★다르면 오류발생------------------------------------------------------------------------------------------------------------------------------------
--※ Oracle SQL에서만 지원
--조인결과, 중복된 컬럼 제거함





