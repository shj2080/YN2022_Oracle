/************************************************************************
 * < 참조 : 오라클 실행 순서 >
 * from -> where -> group by -> having -> select 컬럼명의 별칭 -> order by
 * 
 * 따라서 where절에서 '컬럼명의 별칭' 인식 못함 (즉, where + '컬럼명의 별칭' 사용불가)
 * 
 * 단, 아래 SQL문은 where절에 별칭 사용가능
 * select *
 * from (select salary AS "급여" from employee)
 * where "급여" > 1000;
 ************************************************************************/
--[순서-1]
select salary AS "급여" from employee;
--[순서-2]
select *
from (select salary AS "급여" from employee)
where "급여" > 1000;

select salary AS "급여"
from employee
--where "급여" > 1000; --[오류]ORA-00904: "급여": invalid identifier
where salary > 1000; --가능



--<북스-5장> 그룹 함수 : '하나 이상의 행을 그룹으로 묶어 연산'하여 총합, 평균 등 결과를 구함
--★★ 주의 : count(*) 함수를 제외한 모든 그룹함수들은 null값은 무시

--사원들의 급여 총액, 급여 평균액, 급여 최고액, 급여 최저액 출력
select
SUM(salary),
AVG(salary),--실수
--trunc(AVG(salary)) --정수
MAX(salary),
MIN(salary)
from employee;
--'전체 사원테이블'이 대상이면 group by 사용안함(이유?전체가 하나의 그룹이므로...)

--max(), min() 함수는 숫자데이터 이외에 다른 '모든 데이터 유형'에 사용가능
--[문제] 최근에 입사한 사원과 가장 오래전에 입사한 사원의 입사일을 출력
select
MAX(hiredate) as "최근사원",
MIN(hiredate) as "첫 사원"--별칭이 너무 길면 오류 발생함
from employee;

--1.1 그룹함수와 NULL값(145P~)
--사원들의 커미션 총액 출력
select
sum(commission) as "커미션 총액"
from employee;--2200
--null값과 연산한 결과는 무조건 null이 나오지만
--count(*) 함수를 제외한 모든 그룹함수들은 null값은 무시

--1.2 '행 개수'를 구하는 count함수
select count(*) as "전체 사원수"
from employee; --14

--커미션을 받는 사원수
--[방법-1] count(*) : null제외안함
select count(*) as "커미션을 받는 사원수"
from employee
where commission IS NOT null;

--[방법-2] count(컬럼명) : null제외
select count(commission) as "커미션을 받는 사원수"
from employee;

--직업(job)이 어떤 종류?
select job
from employee;

select DISTINCT job --distinct : 중복 제외
from employee;

--직업(job)의 개수
select count(job), count(ALL job) as "ALL한 직업수"
from employee;--14	14

select count(commission), count(ALL commission) as "ALL한 커미션", count(*)
from employee;--4	4	14

--업(job)의 개수 : DISTINCT (중복 제외)
select count(job), count(distinct job) as "중복제외한 직업수"
from employee;

--★★★★★★★★★ 1-3. 그룹함수와 단순컬럼 ★★★★★★★★★★★★★★★★★★★★★★★★★★
SELECT ename, max(salary) --다:1
from EMPLOYEE;--ORA-00937: not a single-group group function
--오류? 그룹함수의 결과값은 1개인데, 
--그룹함수를 적용하지 않은 컬럼은 결과가 여러 개 나올 수 있으므로
--매치시킬 수 없기 때문에 오류발생

--2. 데이터 그룹 : GROUP BY - 특정 컬럼을 기준으로 그룹별로 나눠야 할 경우
-- ★★ group by 절 뒤에 '컬럼의 별칭' 사용불가. 반드시 컬럼명만 기술

--[문제] 소속 부서별로 평균급여를 부서번호와 함께 출력(부서번호를 기준으로 오름차순 정렬)
--[순서-1]
select distinct dno
from employee; --10 20 30

--[순서-2]
select dno, AVG(salary)--1 : 1
from employee
GROUP BY dno--10 20 30
order by dno asc;

select AVG(salary) --dno(부서번호)가 없으면 결과는 무의미해짐
from employee
GROUP BY dno--10 20 30
order by dno asc;

--오류? ORA-00979: not a GROUP BY expression
select dno, ename, AVG(salary)--3 : 14 : 3
from employee
GROUP BY dno--10 20 30
order by dno asc;

select dno, ename, AVG(salary)--14 : 14
from employee
GROUP BY dno, ename--(10, 같은이름) (20, 같은이름) (30, 같은이름)
order by dno asc;

select dno, job, count(*), SUM(salary), AVG(salary)
from employee
GROUP BY dno, job--(10, 같은직업) (20, 같은직업) (30, 같은직업)
order by dno asc;
--GROUP BY 절은 먼저 dno(부서번호)를 기준으로 그룹화한 다음
--해당 부서 번호 그룹 내에서 job(직업)을 기준으로 다시 그룹화

--3. 그룹 함수 제한 : havikng (152p~)
--그룹 함수의 결과 중 having절 다음에 지정한 조건에 true인 그룹으로 결과 제한

--[문제] '부서별 급여총액이 10000이상'인 부서의 부서번호와 부서별 급여총액 구하기
--(부서번호로 오름차순 정렬)





