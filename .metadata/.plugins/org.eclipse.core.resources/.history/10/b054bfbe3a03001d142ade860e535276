--<북스-6장.테이블 조인하기>
--1. 조인
--1.1 카디시안 곱(=곱집합) : (구방식 ,) (현방식 cross join) - 조인조건이 없다.
select * from EMPLOYEE; 	--컬럼(속성)수 : 8, 행수:14
select * from department;   --컬럼수:3, 행수:4

select *	--컬럼수:11, 행수:56
from employee, department;
--조인결과 : 컬럼수(11) = 사원테이블의 컬럼수(8) + 부서테이블의 컬럼수(3)
--		   행수(56) = 사원테이블의 컬럼수(14) * 부서테이블의 컬럼수(4)
--		   	       = 사원테이블의 사원 1명 당 * 부서테이블의 행수(4)

select eno	-- eno 컬럼만, 56개 전체 행수
from employee, department;

select eno	-- eno 컬럼만, 56개 전체 행수
from employee CROSS JOIN department;

select *	--컬럼수:11, eno가 7369인 것만
from employee, department
where eno = 7369;--(조인조건아님)검색조건

--1.2 조인의 유형
--오라클 8i이전 조인 : EQUI 조인(=등가 조인), non-EQUI 조인(=비등가 조인), outer 조인(왼쪽, 오른쪽), self 조인
--오라클 9i이후 조인 : cross 조인, natural 조인(=자연 조인), join~using, outer 조인(왼쪽, 오른쪽, full까지)
--(※오라클 9i부터 ANSI 표준 SQL 조인 : 현재 대부분의 상용 데이터베이스 시스템에서 사용.
--								다른 DBMS와 호환이 가능하기 때문에 ANSI 표준 조인에 대해서 확실히 학습하자.)

--------<아래 4가지 비교 : 내부조인(=inner join)>------------------------------------------------------------------
--[해결할 문제] '사원번호가 7788'인 사원이 소속된 '사원번호, 사원이름, 소속부서번호, 소속부서이름' 얻기
-- 먼저, '사원번호, 사원이름, 소속부서번호, 소속부서이름'의 컬럼들이 어느 테이블에 있는지 부터 파악하기
-- '사원번호, 사원이름, 소속부서번호(dno)' => 사원테이블에 있음
-- '소속부서번호(dno), 소속부서이름' => 부서테이블에 있음

-- '소속부서번호'가 양 테이블에 존재하므로 등가 조인이 가능함
--2. equi 조인(=등가 조인=동일조인) : 동일한 이름과 유형(=데이터 타입)을 가진 컬럼으로 조인
--  단, [방법-1] , ~ where 과 [방법-2] JOIN ~ ON은 '데이터 타입만 같아도 조인'이 됨

--[방법-1] , ~ where ------------------------------------------------------------------------------------------------------------------------------------
--동일한 이름과 데이터 유형을 가진 컬럼으로 조인 + "임의의 조건을 지정"하거나 "조인한 컬럼을 지정"할 때 where절을 사용
--조인결과는 중복된 컬럼 제거X -> 따라서, 테이블에 '별칭 사용'해서 어느 테이블의 컬럼인지 구분해야 함
select 컬럼명1, 컬럼명2...--중복되는 컬럼은 반드시 '별칭.컬럼명'(예)e.dno	d.dno
from 테이블1 별칭1, 테이블2 별칭2, ... --별칭사용(별칭 : 해당 SQL명령문내에서만 유효)
where ★조인조건	(※주의 : 테이블의 별칭 사용);
AND	  ★(검색조건)	(※주의 : 습관적으로 () 사용하기)
--★문제점 : 원하지 않는 결과가 나올 수 있다.(이유? AND -> OR의 우선순위 때문에)
--★문제점 해결법 : AND	  ★검색조건에서 '괄호()를 이용하여 우선순위 변경'
--예)부서번호로 조인한 후 부서번호가 10이거나 30인 정보 조회
--where e.dno = d.dno AND d.dno = 10 OR d.dno = 30; --문제 발생(원하지 않는 결과 나옴)
--where e.dno = d.dno AND (d.dno = 10 OR d.dno = 30);--★해결법 : '괄호()를 이용하여 우선순위 변경'

--★★★ [장점] 이 방법은 outer join(=외부조인) 하기가 편리하다.
--(단, 한 쪽에만 (+)사용가능  -> 즉, 왼쪽과 오른쪽 외부조인만 가능.
--		양쪽에 (+)사용불가  -> 즉, full 외부조인은 불가 )
--[1]
select *
from employee, department
order by eno;
--[2]별칭 사용 안한 경우
select *
from employee, department
where employee.dno = department.dno;
--[2]별칭 사용한 경우
select *
from employee e, department d
where e.dno = d.dno;
--두 테이블에서 같은 dno끼리 조인(그 결과 부서테이블의 40은 표시안됨.)

-- 40부서의 정보를 함께 표시하기 위해서는 (+)붙여서 outer join(=외부조인)함.
--[3]
select *
from employee e, department d
where e.dno(+) = d.dno;
--외부조인하기 편리하나 full outer join 안됨
--full outer join은 join~on으로 해결가능함

--[3] 아래 결과는 같다. 그 이유? DEPARTMENT 테이블에만 표시될 내용이 더 있으므로...
select *
from employee e RIGHT OUTER JOIN department d
ON e.dno = d.dno;

select *
from employee e FULL OUTER JOIN department d
ON e.dno = d.dno;

--[해결할 문제] '사원번호가 7788'인 사원이 소속된 '사원번호, 사원이름, 소속부서번호, 소속부서이름' 얻기
--[문제해결법]
--select e.eno, e.ename, e.dno, d.dname	-- ok
select eno, ename, e.dno, dname--e.dno에는 반드시 별칭사용 : 두 테이블에 모두 존재하므로 구분하기 위해
from employee e, department d
where e.dno = d.dno
AND eno = 7788;

--[방법-2] (INNER)JOIN ~ ON ------------------------------------------------------------------------------------------------------------------------------------
--동일한 이름과 데이터 유형을 가진 컬럼으로 조인 + "임의의 조건을 지정"하거나 "조인한 컬럼을 지정"할 때 ON절을 사용
--조인결과는 중복된 컬럼 제거X -> 따라서, 테이블에 '별칭 사용'해서 어느 테이블의 컬럼인지 구분해야 함
select 컬럼명1, 컬럼명2...--중복되는 컬럼은 반드시 '별칭.컬럼명'(예)e.dno	d.dno
from 테이블1 별칭1 (INNER)JOIN 테이블2 별칭2, ... --별칭사용(별칭 : 해당 SQL명령문내에서만 유효)
ON 		  ★조인조건	(※주의 : 테이블의 별칭 사용);
where	  ★(검색조건)

--[해결할 문제] '사원번호가 7788'인 사원이 소속된 '사원번호, 사원이름, 소속부서번호, 소속부서이름' 얻기
--[문제해결법]
--select e.eno, e.ename, e.dno, d.dname	-- ok
select eno, ename, e.dno, dname--e.dno에는 반드시 별칭사용 : 두 테이블에 모두 존재하므로 구분하기 위해
from employee e JOIN department d
ON e.dno = d.dno
where eno = 7788;

-------------------------------------[방법-1]과 [방법-2]는 문법적 특징이 동일하다.
-------------------------------------				의 조인 결과 : 중복된 컬럼 제거X -> 테이블의 별칭 필요
-------------------------------------			  ★ 컬럼명이 다르고 데이터 타입만 같아도 JOIN 가능 (예)a.id = b.id2

-------------------------------------[방법-3] : 컬럼명이 다르면 cross join 결과가 나옴
-------------------------------------[방법-4] : 컬럼명이 다르면 join 안됨 (=>오류 발생)


--[방법-3] NATURAL JOIN (=자연조인) ------------------------------------------------------------------------------------------------------------------------------------
--※ Oracle SQL에서만 지원
--조인결과, 중복된 컬럼 제거함

--'자연스럽게' 동일한 이름과 데이터 유형을 가진 컬럼으로 조인(★단, 1개만 있을 때 사용하는 것을 권장)
--동일한 이름과 데이터 유형을 가진 컬럼이 없으면 cross join 이 됨
--★★ 동일한 이름과 데이터 유형을 가진 컬럼으로 자연스럽게 조인되나 문제가 발생할 수 있다.
-----> 문제 발생하는 이유? (예)EMPLOYEE의 dno와 DEPARTMENT의 dno : 동일한 이름(dno)과 데이터 유형(number(2))
--														  ★ 두 테이블에서 dno는 '부서번호'로 의미도 같다.
--					 만약, EMPLOYEE의 manager_id(각 사원의 '상사'를 의미하는 번호)가 있고
--					    DEPARTMENT의 manager_id(각 사원의 '부장'를 의미하는 번호)가 있다고 가정했을 때
--						둘 다 동일한 이름과 데이터 유형을 가졌지만 manager_id의 의미가 다르다면 '자연조인한 후 원하지 않는 결과'가 나올 수 있다.

select 컬럼명1, 컬럼명2...
from 테이블1 별칭1 NATURAL JOIN 테이블2 별칭2, ... --별칭 사용안함(권장)
--★조인조건 필요없음
where	  ★(검색조건)

--[문제해결법-1]
--select eno, ename, dno, dname
select e.eno, e.ename, dno, d.dname		--dno는 중복 제거 했으므로 e.dno, d.dno 별칭사용 안함
from employee e natural JOIN department d 
--ON e.dno = d.dno
where eno = 7788;
--[문제해결법-2_간략]
select eno, ename, dno, dname
from employee natural JOIN department
where eno = 7788;

--[방법-4] JOIN ~ USING(★반드시 '동일한 데이터 유형을 가진 컬럼명'만 가능) ★다르면 오류발생------------------------------------------------------------------------------------------------------------------------------------
--※ Oracle SQL에서만 지원
--조인결과, 중복된 컬럼 제거함

--natural JOIN 은 같은 데이터 유형과 이름을 가진 컬럼을 모두 join 하지만
--USING 은 같은 데이터 유형과 이름을 가진 컬럼들 중에서도 특정컬럼만 따로 선택할 수 있다.

--조인결과는 중복된 컬럼 제거 -> 제거한 결과에 FULL outer join ~ USING(id)하면 하나의 id로 항목값들이 합쳐져서 표시됨
--동일한 이름과 유형을 가진 컬럼으로 조인(★조인 시 1개 이상 사용할 때 편리 : 가독성이 좋아서...)

select 컬럼명1, 컬럼명2...
from 테이블1 별칭1 NATURAL JOIN 테이블2 별칭2, ... --별칭 사용안함(권장)
USING(★조인조건) --USING(동일한 타입과 컬럼명1, 동일한 타입과 컬럼명2) 
where	  ★(검색조건)

--[문제해결법-1]
select e.eno, e.ename, dno, d.dname	--dno는 중복 제거 했으므로 e.dno, d.dno 별칭사용 안함
from employee e JOIN department d --별칭 만들어도 되나
USING (dno)
where eno = 7788;

--[문제해결법-2_간략]
select eno, ename, dno, dname
from employee JOIN department
USING (dno)
where eno = 7788;

--★★ 만약, manager가 department에 있다고 가정 후 아래 결과 유추
select eno, ename, dno, dname, e.manager, d.manager		--★반드시 '테이블명이나 별칭 사용'하여 구분해야 함
from employee e JOIN department d
USING (dno)--dno만 중복제거(★manager는 중복제거 안 함)
where eno = 7788;

--USING을 사용하면 여러개의 컬럼을 기술할 수 있다.
--※ 이 때 기술된 여러 컬럼의 값은 하나의 값으로 묶어서 판단해야 한다.
--[예] 실습을 위해 테이블 생성 후 데이터 추가
create table emp_test(
eno number primary key,
dno_id number,
loc_id char(2)
);

insert into emp_test values(1, 10, 'A1');
insert into emp_test values(2, 10, 'A2');
insert into emp_test values(3, 20, 'A1');

create table dept_test(
dno_id number primary key,
dname varchar2(20),
loc_id char(2)
);

insert into dept_test values(10, '회계', 'A1');
insert into dept_test values(20, '경영', 'A1');
insert into dept_test values(30, '영업', 'A2');

--USING 조인
select *
from emp_test JOIN dept_test
USING(dno_id, loc_id);
--'10A1', '20A1'은 조인결과에 포함되나 '10A2'나 '30A2'는 조인결과에 포함되지 않음
--이에 따라 두 테이블에 공통요소인 '10A1', '20A1'만 조인된 출력결과를 확인할 수 있다.

--※ 여러 테이블 간 조인할 경우 NATURAL JOIN과 JOIN~USING을 이용한 조인 모두 사용 가능하나
--가독성이 높은 JOIN~USING을 이용하는 방법을 권한다.
-------------------------[방법-3] : 컬럼명이 다르면 cross join 결과가 나옴
-------------------------[방법-4] : 컬럼명이 다르면 join 안됨(오류 발생)

-------------------<4가지 정리 끝>---------------------------------------------------------------------------


--3. non-equi 조인(=비등가조인) : 조인조건에서 '=(같다) 연산자 이외'의 연산자를 사용할 때
--							(예) !=	>	<	>=	<=	between~and

--[문제] 사원 별로 '사원이름, 급여, 급여등급' 출력
--[1]. '사원이름, 급여 => 사원테이블,		급여등급 => 급여등급 테이블'
--사원 테이블 출력
select * from EMPLOYEE;
--급여등급 테이블 출력
select * from SALGRADE;

--[2] 두 테이블에는 동일한 이름과 타입을 가진 컬럼이 존재하지 않는다.
--따라서, 비등가 조인함
--join 방법-2
select ename, salary, grade
from EMPLOYEE JOIN SALGRADE -- 별칭 사용안함(이유? 중복되는 컬럼이 없으므로)
ON salary between losal and hisal; --조인조건(=>비등가 조인조건)

--join 방법-1
select ename, salary, grade
from EMPLOYEE , SALGRADE -- 별칭 사용안함(이유? 중복되는 컬럼이 없으므로)
where salary between losal and hisal; --조인조건(=>비등가 조인조건)


--[문제] 사원 별로 '사원이름, 급여, 급여등급' 출력 + [조건추가] : 급여가 1000미만이거나 2000초과
--join 방법-2 => 정확한 결과 O
select ename, salary, grade
from employee JOIN salgrade	-- 별칭 사용안함(이유? 중복되는 컬럼이 없으므로)
on salary between losal and hisal --조인조건(=>비등가 조인조건)
where salary < 1000 or salary > 2000; --[검색조건] 추가

--join 방법-1 => 정확한 결과 X
-- 이유 : AND와 OR 함께 있으면 AND 실행 후 OR 실행
-- => 해결법 : ()괄호 이용하여 우선순위 변경
select ename, salary, grade
from employee, salgrade	-- 별칭 사용안함(이유? 중복되는 컬럼이 없으므로)
where salary between losal and hisal --조인조건(=>비등가 조인조건)
AND salary < 1000 or salary > 2000; --[검색조건] 추가

--위 문제 해결된 SQL문 : ()로 우선순위 변경
select ename, salary, grade
from employee, salgrade	-- 별칭 사용안함(이유? 중복되는 컬럼이 없으므로)
where salary between losal and hisal --조인조건(=>비등가 조인조건)
AND (salary < 1000 or salary > 2000); --[검색조건] 추가

--------------------------------------------------------------------------------------
--[문제] 3개의 테이블 조인하기
--'사원이름, 소속된 부서번호, 소속된 부서명, 급여, 급여등급' 조회
--[1] 사원테이블 : 사원이름, 급여, 소속된 부서번호
--	  부서테이블 : 소속된 부서번호, 소속된 부서명
--	  급여등급테이블 : 급여등급
--[1-1] 사원테이블과 부서테이블은 동일한 이름과 타입을 가진 컬럼이 존재(소속된 부서번호 dno)
--		=> 등가조인
--[join 방법-1]
select ename, e.dno, dname, salary	--e.dno:구분하기 위해 생략불가
from EMPLOYEE e, DEPARTMENT d
where e.dno = d.dno;


