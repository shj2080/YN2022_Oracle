--<북스-4장.다양한 함수>
/*****<문자함수>******************************************/
--1. 대소문자 변환함수
select 'Apple',
upper('Apple'),		--대문자로 변환
lower('Apple'),		--소문자로 변환
initcap('aPPLE')	--첫글자만 대문자, 나머지는 소문자로 변환
from dual;--가상테이블

--대소문자 변환함수 어떻게 활용되는지 살펴보기
--'scott' 사원의 사원번호, 이름, 부서번호 출력
select * from employee;

select ename, lower(ename), initcap(ename)
from employee;

select eno, ename, dno
from employee
where lower(ename) = 'scott';
--비교대상인 사원이름을 모두 소문자로 변환하여 비교

select eno, ename, dno
from employee
where ename = upper('scott');
--값을 대문자로 변환하여 비교

select eno, ename, dno
from employee
where initcap(ename) = 'Scott';


--2. 문자길이를 반환하는 함수
--영문, 수, 특수문자(1byte) 또는 한글의 길이 구하기
--length() : 문자 수
select length('Apple'), length('사과')
from dual;--5  2

--lengthB() : 한글2bytes-'인코딩 방식'에 따라 달라짐(UTF-8:한글 1글자가 '3바이트')
select lengthB('Apple'), lengthB('사과')
from dual;	--5바이트  6바이트

--3. 문자 조작 함수
--concat('문자열1', '문자열2') : '두 문자열'을 하나의 문자열로 연결(=결합)
--		★반드시 2 문자열만 연결 가능 = 매개변수 2개만
--매개변수=인수=인자=argument
select 'Apple', '사과',
concat('Apple', '사과') as "함수 사용",--자바에서는 "Apple".concat("사과")
'Apple' || '사과' || '맛있어' as "|| 사용"--자바에서는 "Apple" + "사과" + "맛있어"
from dual;

--substr(기존문자열, 시작index, 추출할 개수) : 문자열의 일부만 추출하여 부분문자열
--시작index : 음수이면 문자열의 마지막을 기준으로 거슬러 올라감
--인덱스(index) : 1 2 3...(※자바 index : 0 1 2...)
select substr('apple mania', 7, 5),--'mania'
substr('apple mania', -11, 5)--'apple'
from dual;

--[문제1] '이름이 N으로 끝나는' 사원 정보 표시
--방법-1:like연산자와 와일드카드(% _) 이용
select *
from employee
where ename LIKE '%N';

--방법-2:substr() 이용
select *
from employee
where substr(ename, -1, 1) = 'N';

select *
from employee
where lower(substr(ename, -1, 1)) = 'n';

select ename, substr(ename, -1, 1)
from employee
where substr(ename, -1, 1) = 'N';

select *
from employee
where substr(ename, length(ename), 1) = 'N';

--[문제2] 87년도에 입사한 사원 정보 탐색
--[방법-1]
select *
from employee
where substr(hiredate, 1, 2) = '87';	--오라클 : 날짜 기본 형식 'YY/MM/DD'
--where substr(hiredate, 1, 4) = '1987';	--결과 없음

--[방법-2]
--TO_CHAR(수나 날짜, '형식') : 수나 날짜를 원하는 형식의 문자로 형변환함
select *
from employee
--where substr(to_char(hiredate, 'yyyy'), 1 , 4) = '1987';--substr('1987', 1, 4)
where substr(to_char(hiredate, 'yyyy-mm-dd'), 1, 4) = '1987';--substr('1987-11-12', 1, 4)

--[문제3] '급여가 50으로 끝나는' 사원의 사원이름과 급여 출력
--[방법-1]
select ename, salary
from employee
where salary LIKE '%50';	--salary는 실수 number(7,2)타입이지만 '문자로 자동형변환'되어 비교

--[방법-2]
select ename, salary
from employee		--시작index : 끝에서 2번째부터 ㅣ작해서 2개 문자로 부분문자열 생성
--where substr(salary, -2, 2) = '50';	--salary는 실수 number(7,2)타입이지만 '문자로 자동형변환'
where substr(salary, -2, 2) = 50;	--'50'=50		50=50 (문자'50'이 수50으로 자동형변환되어 비교됨)

--[방법-3] : 자동 형변환되어 비교된다는 사실을 모르면?
--substr()는 문자함수
select ename, salary
from employee
where substr(to_char(salary), -2, 2) = '50';--TO_CHAR(수나 날짜)를 문자로 형변환해야 함

--substrB(기본문자열, 시작index, 추출할 바이트수)
select substr('사과매니아', 1, 2), -- '사과'
substrB('사과매니아', 1, 3),--'사' 1부터 시작해서 3바이트 추출해서 부분문자열을 생성
substrB('사과매니아', 4, 3),--'과'
substrB('사과매니아', 1, 6)--'사과'
from dual;

--instr(대상문자열, 찾을 문자열, 시작 index, 몇 번째 발견) : 대상문자열 내에 찾고자 하는 해당 문자열이 어느 '위치(=index번호)'에 존재하는지 index번호 리턴










